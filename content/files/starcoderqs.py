# -*- coding: utf-8 -*-
"""StarCoderQS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EQDNpl6P_Aqjcv7zyHqP8Yxx5W9Uf5ha

# Star Coder - Quality-Stratification of Starcoder Translations
"""

!apt-get update
!apt-get install -y g++ clang

import json
import random

FILE_PATH = "/content/codenet_single_solution_starcoder.jsonl"
NUM_SAMPLES = 5

with open(FILE_PATH, "r", encoding="utf-8") as f:
    lines = f.readlines()

samples = random.sample(lines, min(NUM_SAMPLES, len(lines)))

for i, line in enumerate(samples, 1):
    data = json.loads(line.strip())
    print(f"\n--- Random Instance {i} ---")
    print(json.dumps(data, indent=2, ensure_ascii=False))

import json
import re
from pathlib import Path

# -------------------------
# Configuration
# -------------------------

INPUT_JSONL = "/content/codenet_single_solution_starcoder.jsonl"
OUTPUT_JSONL = "/content/codenet_single_solution_starcoder_clean.jsonl"

MIN_CODE_LENGTH = 80  # characters

# -------------------------
# Detection rules
# -------------------------

JAVA_START_PATTERNS = [
    r"^\s*import\s+java\.",
    r"^\s*import\s+javax\.",
    r"\bpublic\s+class\b",
    r"\bclass\s+\w+",
]

INVALID_JAVA_MARKERS = [
    "#include",
    "scanf(",
    "printf(",
    "cout<<",
    "cin>>",
    "using namespace",
    "std::",
]

CASCADE_MARKERS = [
    "### Translate the following",
    "### C translation",
    "### C++ translation",
    "### Python translation",
    "### Ruby translation",
    "### JavaScript translation",
    "### C# translation",
    "### Output:",
]

LEETCODE_MARKERS = [
    "leetcode.com",
    "class Solution",
    "Minimum Number of Steps",
]

# -------------------------
# Core cleaning logic
# -------------------------

def extract_java_block(text: str) -> str | None:
    """
    Extract the actual Java code block.
    Returns cleaned Java code or None.
    """

    if not text:
        return None

    # Remove markdown fences
    text = re.sub(r"```java|```", "", text, flags=re.IGNORECASE)

    # Remove everything after cascade markers
    for marker in CASCADE_MARKERS:
        idx = text.find(marker)
        if idx > 0:
            text = text[:idx]

    lines = text.splitlines()

    # Find Java start
    start = -1
    for i, line in enumerate(lines):
        for pat in JAVA_START_PATTERNS:
            if re.search(pat, line):
                start = i
                break
        if start != -1:
            break

    if start == -1:
        return None

    java_code = "\n".join(lines[start:]).strip()

    if len(java_code) < MIN_CODE_LENGTH:
        return None

    return java_code


def is_invalid_java(code: str) -> bool:
    lower = code.lower()

    for bad in INVALID_JAVA_MARKERS:
        if bad in code:
            return True

    for bad in LEETCODE_MARKERS:
        if bad.lower() in lower:
            return True

    # Must contain at least one class
    if not re.search(r"\bclass\s+\w+", code):
        return True

    return False


# -------------------------
# Main processing
# -------------------------

def clean_jsonl():
    kept = 0
    dropped = 0

    with open(INPUT_JSONL, "r", encoding="utf-8") as fin, \
         open(OUTPUT_JSONL, "w", encoding="utf-8") as fout:

        for line in fin:
            obj = json.loads(line)

            raw = (
                obj.get("starcoder_translation_clean")
                or obj.get("starcoder_translation_raw")
            )

            java_code = extract_java_block(raw)

            if java_code and not is_invalid_java(java_code):
                obj["translated_java_code"] = java_code
                fout.write(json.dumps(obj, ensure_ascii=False) + "\n")
                kept += 1
            else:
                dropped += 1

    print("Cleaning complete")
    print(f"Kept   : {kept}")
    print(f"Dropped: {dropped}")


# -------------------------
# Entry point
# -------------------------

if __name__ == "__main__":
    clean_jsonl()

import json
import subprocess
import tempfile
import os
import re
import shutil

# =========================
# CONFIG
# =========================

STARCODER_FILE = "/content/codenet_single_solution_starcoder_clean.jsonl"
PROBLEM_TESTS_FILE = "/content/problem_tests.json"
OUTPUT_JSONL = "/content/codenet_single_solution_starcoder_scored.jsonl"

EXEC_TIMEOUT = 5  # seconds
PROGRESS_INTERVAL = 10

# =========================
# JAVA DETECTION RULES
# =========================

JAVA_START_PATTERNS = [
    r"^\s*import\s+java\.",
    r"^\s*import\s+javax\.",
    r"\bpublic\s+class\b",
    r"\bclass\s+\w+",
]

CASCADE_MARKERS = [
    "### Translate the following",
    "### C translation",
    "### C++ translation",
    "### Python translation",
    "### Ruby translation",
    "### JavaScript translation",
    "### C# translation",
    "### Output:",
]

INVALID_JAVA_MARKERS = [
    "#include",
    "scanf(",
    "printf(",
    "cout<<",
    "cin>>",
    "using namespace",
    "std::",
]

# =========================
# COUNT TOTAL INSTANCES
# =========================

def count_jsonl_lines(path):
    with open(path, "r", encoding="utf-8") as f:
        return sum(1 for _ in f)

TOTAL_INSTANCES = count_jsonl_lines(STARCODER_FILE)
print(f"Total instances in file : {TOTAL_INSTANCES}")

# =========================
# LOAD TEST CASES
# =========================

def load_tests(path):
    tests = {}
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
        for item in data:
            pid = item["problem_id"]
            if pid not in tests:
                tests[pid] = {
                    "input": item["input"],
                    "output": item["output"].strip()
                }
    return tests

PROBLEM_TESTS = load_tests(PROBLEM_TESTS_FILE)

# =========================
# JAVA EXTRACTION
# =========================

def extract_java_code(text):
    if not text:
        return None

    # Remove markdown fences
    text = re.sub(r"```java|```", "", text, flags=re.IGNORECASE)

    # Cut off cascaded translations
    for marker in CASCADE_MARKERS:
        idx = text.find(marker)
        if idx > 0:
            text = text[:idx]

    lines = text.splitlines()

    start = -1
    for i, line in enumerate(lines):
        for pat in JAVA_START_PATTERNS:
            if re.search(pat, line):
                start = i
                break
        if start != -1:
            break

    if start == -1:
        return None

    code = "\n".join(lines[start:]).strip()

    # Must contain a class
    if not re.search(r"\bclass\s+\w+", code):
        return None

    # Reject obvious non-Java remnants
    for bad in INVALID_JAVA_MARKERS:
        if bad in code:
            return None

    return code

# =========================
# JAVA PARSE / COMPILE
# =========================

def java_compiles(code):
    tmpdir = tempfile.mkdtemp()
    java_file = os.path.join(tmpdir, "Main.java")

    with open(java_file, "w", encoding="utf-8") as f:
        f.write(code)

    compile_proc = subprocess.run(
        ["javac", java_file],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE
    )

    if compile_proc.returncode != 0:
        shutil.rmtree(tmpdir)
        return False, tmpdir

    return True, tmpdir

def run_java(tmpdir, test_input):
    try:
        result = subprocess.run(
            ["java", "-cp", tmpdir, "Main"],
            input=test_input,
            text=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            timeout=EXEC_TIMEOUT
        )
        return result.stdout.strip()
    except Exception:
        return None

# =========================
# EVALUATION
# =========================

def evaluate_starcoder():
    stats = {
        "total": 0,
        "score_0": 0,
        "parsable": 0,
        "compilable": 0,
        "functional": 0
    }

    with open(STARCODER_FILE, "r", encoding="utf-8") as fin, \
         open(OUTPUT_JSONL, "w", encoding="utf-8") as fout:

        for idx, line in enumerate(fin, start=1):
            item = json.loads(line)
            stats["total"] += 1

            problem_id = item.get("problem_id")
            raw_translation = item.get("translated_java_code")

            score = 0

            # ---------- Extract Java ----------
            java_code = extract_java_code(raw_translation)

            if java_code is None:
                stats["score_0"] += 1
                item["score"] = 0
                fout.write(json.dumps(item) + "\n")
                continue

            stats["parsable"] += 1
            score = 1

            # ---------- Test lookup ----------
            test = PROBLEM_TESTS.get(problem_id)
            if test is None:
                item["score"] = score
                fout.write(json.dumps(item) + "\n")
                continue

            # ---------- Compile ----------
            compilable, tmpdir = java_compiles(java_code)

            if not compilable:
                item["score"] = score
                fout.write(json.dumps(item) + "\n")
                continue

            stats["compilable"] += 1
            score = 2

            # ---------- Functional ----------
            output = run_java(tmpdir, test["input"])
            shutil.rmtree(tmpdir)

            if output == test["output"]:
                stats["functional"] += 1
                score = 3

            item["score"] = score
            fout.write(json.dumps(item) + "\n")

            # ---------- Progress ----------
            if idx % PROGRESS_INTERVAL == 0 or idx == TOTAL_INSTANCES:
                percent = (idx / TOTAL_INSTANCES) * 100
                print("\n----------------------------------------")
                print(f"Progress: {idx}/{TOTAL_INSTANCES} ({percent:.2f}%)")
                print(f"Score 0       : {stats['score_0']}")
                print(f"Parsable      : {stats['parsable']}")
                print(f"Compilable    : {stats['compilable']}")
                print(f"Functional    : {stats['functional']}")
                print("----------------------------------------")

    # =========================
    # FINAL REPORT
    # =========================

    t = stats["total"]

    print("\n==============================")
    print("FINAL StarCoder Java Results")
    print("==============================")
    print(f"Total samples       : {t}")
    print(f"Score 0             : {stats['score_0']}")
    print(f"Parsable            : {stats['parsable']}")
    print(f"Compilable          : {stats['compilable']}")
    print(f"Functional          : {stats['functional']}")

    if t > 0:
        print("\nPercentages:")
        print(f"Score 0      : {stats['score_0']/t:.2%}")
        print(f"Parsable     : {stats['parsable']/t:.2%}")
        print(f"Compilable   : {stats['compilable']/t:.2%}")
        print(f"Functional   : {stats['functional']/t:.2%}")

    print(f"\nScored file written to:\n{OUTPUT_JSONL}")

    return stats

# =========================
# RUN
# =========================

if __name__ == "__main__":
    evaluate_starcoder()